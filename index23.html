<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Image Processing</title>
    <link rel="stylesheet" href="styles.css">

    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js"></script>
    <style>


    </style>
</head>
<body>
    <div id="sidebar">
        <div class="controls">
            <input type="file" id="imageUpload" accept="image/*">
            <label for="imageCount">Number of images per effect:</label>
            <input type="number" id="imageCount" min="1" max="100" value="10">
            <button id="processButton">Process Image</button>
            <button id="fastProcessButton">Fast Process</button>
            <button id="createGifButton">Create GIF</button>
            <button id="mergeEffectsButton">Merge Effects</button>
            <button id="mergeTwoEffectsButton">Merge Two Effects</button>
            <button id="mergeThreeEffectsButton">Merge Three Effects</button>
            <button id="segmentationButton">Segment Image</button>
            <button id="fastProcessSegmentButton">Fast Process Segment</button>

            <button id="fastProcessBtn">Fast Process Segmented Image</button>
        </div>
        <div id="processedImagesContainer"></div>
        <div id="masterCheckboxControl">
            <input type="checkbox" id="masterCheckbox" checked>
            <label for="masterCheckbox">Select/Unselect All</label>
        </div>
        <div id="effectControls"></div>
    </div>
    <div id="drawingControls">
        <label><input type="radio" name="drawMode" value="point" checked>Add Points</label>
        <label><input type="radio" name="drawMode" value="line">Add Lines</label>
        <button id="clearDrawing">Clear All</button>
        <label><input type="checkbox" id="debugMode">Debug Mode</label>
    </div>
    <div id="mainContent">
        <canvas id="imageCanvas"></canvas>
        <div id="resultsContainer"></div>
    </div>

    <script>

let processedFrames = [];
    let clickedPoints = [];
    let lines = [];
    let currentLine = null;
    let drawMode = 'point';
    let segmentedImages = [];

    document.getElementById('segmentationButton').addEventListener('click', handleSegmentation);
    const workers1 = {
    segmentation181: new Worker('segmentation181Worker.js')
};

function getSelectedEffects() {
    return effects.filter(effect => {
        const checkbox = document.getElementById(`${effect}Checkbox`);
        return checkbox && checkbox.checked;
    });
}

function handleSegmentation() {
    // console.log("object");
    const file = imageUpload.files[0];
    if (!file) {
        alert('Please upload an image first.');
        return;
    }

    const img = new Image();
    img.onload = function() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        workers1['segmentation181'].postMessage({
            imageData: imageData,
            value: 30,
            debugMode: document.getElementById('debugMode').checked
        });

        workers1['segmentation181'].onmessage = function(e) {
        if (e.data.imageData) {
            displaySegmentedImage(e.data.imageData);
            separateAndDisplayColorSegments(e.data.imageData, imageData);
            if (Array.isArray(e.data.segments) && e.data.segments.length > 0) {
                console.log('e.data :>> ', e.data);
                console.log('e.data.segments :>> ', e.data.segments);
                segmentedImages = e.data.segments.map(segment => {
                    const canvas = document.createElement('canvas');
                    console.log('canvas :>> ', canvas);
                    canvas.id = "newcanvas"
                    canvas.width = e.data.imageData.width;
                    canvas.height = e.data.imageData.height;
                    const ctx = canvas.getContext('2d');
                    const segmentData = new ImageData(e.data.imageData.width, e.data.imageData.height);
                    segment.forEach(pixel => {
                        const index = pixel * 4;
                        segmentData.data.set(e.data.imageData.data.slice(index, index + 4), index);
                    });
                    ctx.putImageData(segmentData, 0, 0);
                    return canvas;
                });
                console.log('segmentedImages :>> ', segmentedImages);
            } else {
                console.warn('Segments data is empty or not an array');
                segmentedImages = [];
            }
        } else if (e.data.error) {
            console.error('Worker error:', e.data.error);
        } else {
            console.error('Unexpected data structure received from worker');
        }
    };
    };
    img.src = URL.createObjectURL(file);
}

function getImageDataFromImage(imgOrCanvas) {
    let canvas, ctx;
    if (imgOrCanvas instanceof HTMLCanvasElement) {
        canvas = imgOrCanvas;
        ctx = canvas.getContext('2d');
    } else if (imgOrCanvas instanceof HTMLImageElement) {
        canvas = document.createElement('canvas');
        canvas.width = imgOrCanvas.naturalWidth || imgOrCanvas.width;
        canvas.height = imgOrCanvas.naturalHeight || imgOrCanvas.height;
        ctx = canvas.getContext('2d');
        ctx.drawImage(imgOrCanvas, 0, 0);
    } else {
        console.error('Invalid input: expected Image or Canvas element');
        return null;
    }
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function getOriginalImageDataFromSource(sourceId) {
    const canvas = document.getElementById(sourceId);
    console.log('Trying to get canvas with id:', sourceId);
    console.log('Retrieved canvas:', canvas);

    if (!canvas) {
        console.error(`Canvas with id '${sourceId}' not found`);
        return null;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error(`Unable to get 2D context from canvas with id '${sourceId}'`);
        return null;
    }

    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}
function getSegmentedImageData(index) {
    const canvasId = `segmentcanvasid${index}`;
    const canvas = document.getElementById(canvasId);
    if (canvas) {
        const ctx = canvas.getContext('2d');
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    } else {
        console.error(`Canvas with id '${canvasId}' not found`);
        return null;
    }
}


document.getElementById('fastProcessBtn').addEventListener('click', () => {
    segmentedImages.forEach((segmentCanvas, index) => {
        const imageData = getSegmentedImageData(index);
        if (imageData) {
            console.log('imageData :>> ', imageData);
            fastProcessImage(imageData);
        }
    });
});

function displaySegmentedImage(segmentedImageData) {
    const canvas = document.createElement('canvas');
    canvas.width = segmentedImageData.width;
    canvas.height = segmentedImageData.height;
    const ctx = canvas.getContext('2d');

    const data = segmentedImageData.data;
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] === 0) {  // If pixel is fully transparent
            data[i] = data[i + 1] = data[i + 2] = 0;  // Set RGB to black
        }
    }
    
    ctx.putImageData(segmentedImageData, 0, 0);

    const segmentedImage = new Image();
    segmentedImage.src = canvas.toDataURL();
    
    resultsContainer.innerHTML = '<h2>Segmented Image</h2>';
    resultsContainer.appendChild(segmentedImage);
}



function calculateSegmentArea(indices, width) {
    const uniquePixels = new Set(indices.map(i => Math.floor(i / 4)));
    return uniquePixels.size / (width * width); 
}

function getImageDataFromImage(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function getImageDataFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}


document.getElementById('fastProcessSegmentButton').addEventListener('click', () => {
    console.log('Segmented Images:', segmentedImages);
    
    if (!segmentedImages || !Array.isArray(segmentedImages) || segmentedImages.length === 0) {
        console.error('No segmented images available for processing');
        alert('Please segment the image before processing.');
        return;
    }
    
    if (!originalImageData) {
        console.error('Original image data not found');
        alert('Unable to locate the original image data. Please ensure the image is properly uploaded.');
        return;
    }
    
    console.log('Original image data found:', originalImageData);
    
    segmentedImages.forEach((segmentCanvas, index) => {
        if (segmentCanvas && segmentCanvas.getContext) {
            const segmentedImageData = getImageDataFromCanvas(segmentCanvas);
            if (segmentedImageData) {
                console.log(`Processing segment ${index}:`, segmentedImageData);
                fastProcessImage3(originalImageData, segmentedImageData);
            } else {
                console.error(`Failed to get ImageData for segment ${index}`);
            }
        } else {
            console.error(`Invalid canvas for segment ${index}`);
        }
    });
});



function displayProcessedFrames(imageData, effect, segmentIndex) {
    const resultsContainer = document.getElementById('resultsContainer');
    
    // Create a container for this processed image
    const frameContainer = document.createElement('div');
    frameContainer.className = 'frame-container';
    frameContainer.innerHTML = `<h3>Segment ${segmentIndex + 1} - ${effect}</h3>`;
    
    const canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    
    const wrapper = document.createElement('div');
    wrapper.className = 'frame-wrapper';
    wrapper.appendChild(canvas);
    
    frameContainer.appendChild(wrapper);
    resultsContainer.appendChild(frameContainer);
    

    const style = document.createElement('style');
    style.textContent = `
        .frame-container {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .frame-wrapper {
            display: inline-block;
            margin: 5px;
            text-align: center;
        }
        .frame-wrapper canvas {
            border: 1px solid #ccc;
        }
    `;
    // document.head.appendChild(style);
}

function fastProcessSegment() {
    if (segmentedImages.length === 0) {
        alert('Please segment an image first.');
        return;
    }

    const imageCount = parseInt(document.getElementById('imageCount').value, 10);
    const effects = getSelectedEffects();
    console.log('Selected effects for processing:', effects);

    if (effects.length === 0) {
        alert('Please select at least one effect.');
        return;
    }

    processedFrames = [];

    segmentedImages.forEach((segmentCanvas, index) => {
        const ctx = segmentCanvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, segmentCanvas.width, segmentCanvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] === 0) {  // If pixel is fully transparent
                data[i] = data[i + 1] = data[i + 2] = 0;  // Set RGB to black
            }
        }
        effects.forEach(effect => {
            if (workers[effect]) {
                workers[effect].postMessage({
                    imageData: imageData,
                    effectName: effect,
                    frameCount: imageCount,
                    segmentIndex: index
                });

                workers[effect].onmessage = function(e) {
                    console.log('Worker response:', e.data);
                    if (e.data.imageData) {
                        processedFrames.push(e.data.imageData);
                        displayProcessedFrames(e.data.imageData, effect, index);
                    } else if (e.data.error) {
                        console.error(`Worker error (${effect}):`, e.data.error);
                    }
                };
            } else {
                console.error(`Worker for effect ${effect} is not initialized`);
            }
        });
    });


}

function displayProcessedSegment(imageData, effect, segmentIndex) {
    const canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    console.log('imageData :>> ', imageData);
    const wrapper = document.createElement('div');
    wrapper.className = 'canvas-wrapper';
    console.log('segmentIndex :>> ', segmentIndex);
    console.log('effect :>> ', effect);
    wrapper.innerHTML = `<p>Segment ${segmentIndex + 1} - ${effect}</p>`;
    wrapper.appendChild(canvas);

    document.getElementById('resultsContainer').appendChild(wrapper);
}

function displayProcessedSegment(imageData, effect, segmentIndex) {
    const canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    const wrapper = document.createElement('div');
    wrapper.className = 'canvas-wrapper';
    wrapper.innerHTML = `<p>Segment ${segmentIndex + 1} - ${effect}</p>`;
    wrapper.appendChild(canvas);
    document.getElementById('resultsContainer').appendChild(wrapper);
}

function separateAndDisplayColorSegments(segmentedImageData, originalImageData) {
    console.log('segmentedImageData :>> ', segmentedImageData);
    const colorMap = new Map();
    const segmentedData = segmentedImageData.data;
    const originalData = originalImageData.data;
    const width = segmentedImageData.width;
    const height = segmentedImageData.height;
    for (let i = 0; i < segmentedData.length; i += 4) {
        const r = segmentedData[i];
        const g = segmentedData[i + 1];
        const b = segmentedData[i + 2]; 
        const a = segmentedData[i + 3];
        if (a > 0) {
            const color = `${r},${g},${b}`;
            if (!colorMap.has(color)) {
                colorMap.set(color, []);
            }
            colorMap.get(color).push(i);
        }
    }
    const segmentsContainer = document.createElement('div');
    segmentsContainer.id = 'segmentsContainer';
    segmentsContainer.className = 'segments-container';
    resultsContainer.appendChild(segmentsContainer);
    let index = 0;
    colorMap.forEach((indices, color) => {
        const segmentArea = calculateSegmentArea(indices, width);
        if (segmentArea > 0.0029 && segmentArea < 0.4)  {
            const segmentCanvas = document.createElement('canvas');
            segmentCanvas.width = width;
            segmentCanvas.height = height;
            // segmentCanvas.id = "segmentcanvasid";
            segmentCanvas.id = `segmentcanvasid${index}`; // Use a unique ID for each segment

            const segmentCtx = segmentCanvas.getContext('2d');
            const segmentImageData = segmentCtx.createImageData(width, height);
            const segmentData = segmentImageData.data;
            indices.forEach(i => {
                segmentData[i] = originalData[i];
                segmentData[i + 1] = originalData[i + 1];
                segmentData[i + 2] = originalData[i + 2];
                segmentData[i + 3] = 255;
                // segmentData[i + 3] = 0; // Full opacity
            });
            segmentCtx.putImageData(segmentImageData, 0, 0);
            const wrapper = document.createElement('div');
            wrapper.className = 'segment-wrapper';
            wrapper.appendChild(segmentCanvas);
            const label = document.createElement('p');
            label.textContent = `Segment ${index + 1} (${(segmentArea * 100).toFixed(2)}%)`;
            wrapper.appendChild(label);
            segmentsContainer.appendChild(wrapper);
            index++;
        }
    });
}

function isSignificantSegment(imageData, threshold = 0.05) {
    const totalPixels = imageData.width * imageData.height;
    let differentPixels = 0;
    const dominantColor = [imageData.data[0], imageData.data[1], imageData.data[2]];

    for (let i = 0; i < imageData.data.length; i += 4) {
        const r = imageData.data[i];
        const g = imageData.data[i + 1];
        const b = imageData.data[i + 2];

        if (Math.abs(r - dominantColor[0]) > 10 ||
            Math.abs(g - dominantColor[1]) > 10 ||
            Math.abs(b - dominantColor[2]) > 10) {
            differentPixels++;
        }
    }

    return (differentPixels / totalPixels) > threshold;
}

function extractSegments(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const segments = [];
    const segmentMap = new Uint32Array(width * height);
    const segmentColors = [];
    let currentSegment = 0;

    const gridSize = 20;

    function getColor(x, y) {
        const i = (y * width + x) * 4;
        return [imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]];
    }

    function colorDistance(c1, c2) {
        return Math.abs(c1[0] - c2[0]) + Math.abs(c1[1] - c2[1]) + Math.abs(c1[2] - c2[2]);
    }

    for (let y = 0; y < height; y += gridSize) {
        for (let x = 0; x < width; x += gridSize) {
            const color = getColor(x, y);
            segmentColors.push(color);
            
            for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                    segmentMap[(y + dy) * width + (x + dx)] = currentSegment;
                }
            }
            currentSegment++;
        }
    }

    const threshold = 30; // Color similarity threshold
    let changes;
    do {
        changes = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const currentColor = getColor(x, y);
                const currentSegmentIndex = segmentMap[i];
                
                // Check neighbors
                const neighbors = [
                    [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]
                ];
                
                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const ni = ny * width + nx;
                        const neighborSegmentIndex = segmentMap[ni];
                        
                        if (neighborSegmentIndex !== currentSegmentIndex) {
                            const neighborColor = segmentColors[neighborSegmentIndex];
                            if (colorDistance(currentColor, neighborColor) < threshold) {
                                segmentMap[i] = neighborSegmentIndex;
                                changes++;
                                break;
                            }
                        }
                    }
                }
            }
        }
    } while (changes > 0);

    // Create final segments
    const segmentPixels = new Map();
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const segmentIndex = segmentMap[i];
            if (!segmentPixels.has(segmentIndex)) {
                segmentPixels.set(segmentIndex, []);
            }
            segmentPixels.get(segmentIndex).push([x, y]);
        }
    }

    segmentPixels.forEach((pixels, segmentIndex) => {
        if (pixels.length > 100) { // Minimum segment size
            const segmentData = new ImageData(width, height);
            pixels.forEach(([x, y]) => {
                const i = (y * width + x) * 4;
                segmentData.data[i] = imageData.data[i];
                segmentData.data[i + 1] = imageData.data[i + 1];
                segmentData.data[i + 2] = imageData.data[i + 2];
                segmentData.data[i + 3] = 255;
            });
            segments.push(segmentData);
        }
    });

    return segments;
}

function displaySegmentedImagesAboveOriginal(originalImage) {
    resultsContainer.innerHTML = '';

    const segmentedContainer = document.createElement('div');
    segmentedContainer.style.display = 'flex';
    segmentedContainer.style.flexWrap = 'wrap';
    segmentedContainer.style.justifyContent = 'center';
    segmentedContainer.style.marginBottom = '20px';

    if (segmentedImages.length === 0) {
        const noSegmentsMessage = document.createElement('p');
        noSegmentsMessage.textContent = 'No significant segments found.';
        segmentedContainer.appendChild(noSegmentsMessage);
    } else {
        segmentedImages.forEach((canvas, index) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            wrapper.appendChild(canvas);
            const label = document.createElement('p');
            label.textContent = `Segment ${index + 1}`;
            wrapper.appendChild(label);
            segmentedContainer.appendChild(wrapper);
        });
    }

    resultsContainer.appendChild(segmentedContainer);

    const originalCanvas = document.createElement('canvas');
    originalCanvas.width = originalImage.width;
    originalCanvas.height = originalImage.height;
    const ctx = originalCanvas.getContext('2d');
    ctx.drawImage(originalImage, 0, 0);

    const originalWrapper = document.createElement('div');
    originalWrapper.className = 'canvas-wrapper';
    originalWrapper.style.width = '100%';
    originalWrapper.appendChild(originalCanvas);
    const label = document.createElement('p');
    label.textContent = 'Original Image';
    originalWrapper.appendChild(label);

    resultsContainer.appendChild(originalWrapper);
}

function displaySegmentedImages(segmentedData, colorMasks) {
    resultsContainer.innerHTML = '';
    
    const segmentedCanvas = document.createElement('canvas');
    segmentedCanvas.width = segmentedData.width;
    segmentedCanvas.height = segmentedData.height;
    segmentedCanvas.getContext('2d').putImageData(segmentedData, 0, 0);
    resultsContainer.appendChild(segmentedCanvas);

    colorMasks.forEach((maskData, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'canvas-wrapper';
        
        const canvas = document.createElement('canvas');
        canvas.width = maskData.width;
        canvas.height = maskData.height;
        canvas.getContext('2d').putImageData(maskData, 0, 0);
        
        wrapper.appendChild(canvas);
        
        const label = document.createElement('p');
        label.textContent = `Segment ${index + 1}`;
        wrapper.appendChild(label);
        
        resultsContainer.appendChild(wrapper);
    });


}

function displayProcessedFrames(imageData, effect, segmentIndex) {
    console.log('imageData :>> ', imageData);
    console.log('effect :>> ', effect);
    console.log('segmentIndex :>> ', segmentIndex);

    const resultsContainer = document.getElementById('resultsContainer');
    
    // Create a container for this processed image
    const frameContainer = document.createElement('div');
    frameContainer.className = 'frame-container';
    frameContainer.innerHTML = `<h3>Segment ${segmentIndex + 1} - ${effect}</h3>`;
    
    const canvas = document.createElement('canvas');
    canvas.width = 100;  // corrected here
    canvas.height = 100;  // corrected here
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    
    const wrapper = document.createElement('div');
    wrapper.className = 'frame-wrapper';
    wrapper.appendChild(canvas);
    
    frameContainer.appendChild(wrapper);
    resultsContainer.appendChild(frameContainer);
    
    // Add some basic styling if not already added
    if (!document.querySelector('#processed-frames-style')) {
        const style = document.createElement('style');
        style.id = 'processed-frames-style';
        style.textContent = `
            .frame-container {
                margin-bottom: 20px;
                border: 1px solid #ddd;
                padding: 10px;
            }
            .frame-wrapper {
                display: inline-block;
                margin: 5px;
                text-align: center;
            }
            .frame-wrapper canvas {
                border: 1px solid #ccc;
            }
        `;
        // document.head.appendChild(style);
    }
}

async function fastProcessImage1(img) {
    processedImages = {};
    const imageCount = parseInt(imageCountInput.value);
    createAnimationPoints(img, 4, imageCount);
    displayEffectButtons();

    const imagesToProcess = segmentedImages.length > 0 ? segmentedImages : [img];

    for (let imgIndex = 0; imgIndex < imagesToProcess.length; imgIndex++) {
        const currentImg = imagesToProcess[imgIndex];
        const effectPromises = effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked).map(async (effect) => {
            if (!processedImages[effect]) processedImages[effect] = [];
            for (let i = 0; i < imageCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = currentImg.width;
                canvas.height = currentImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(currentImg, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let value = getEffectValue(effect, i, imageCount);
                try {
                    const processedImageData = await applyEffect(effect, imageData, value, clickedPoints, lines);
                    ctx.putImageData(processedImageData, 0, 0);
                    processedImages[effect].push({ value: value, dataUrl: canvas.toDataURL() });
                    updateEffectDisplay(effect);
                    processedFrames.push(canvas);
                } catch (error) {
                    console.error(`Error processing effect ${effect} for image ${i+1}:`, error.message);
                }
            }
        });
        await Promise.all(effectPromises);
    }
    displayProcessedImages();
}

    document.getElementById('mergeTwoEffectsButton').addEventListener('click', mergeTwoEffects);
    document.getElementById('mergeThreeEffectsButton').addEventListener('click', mergeThreeEffects);

    async function mergeTwoEffects() {
        const selectedEffects = effects.filter(effect => 
            document.getElementById(`${effect}Checkbox`).checked
        );

        if (selectedEffects.length < 2) {
            alert('Please select at least 2 effects to merge.');
            return;
        }

        const file = imageUpload.files[0];
        if (!file) {
            alert('Please select an image first.');
            return;
        }

        const img = await createImageBitmap(file);
        const imageCount = parseInt(imageCountInput.value);
        let allMergedImages = [];

        resultsContainer.innerHTML = '';

        for (let i = 0; i < selectedEffects.length; i++) {
            const effect1 = selectedEffects[i];
            const effect2 = selectedEffects[(i + 1) % selectedEffects.length];
            const mergedImages = await mergePairOfEffects(img, effect1, effect2, imageCount);
            
            // Display the merged results for this pair
            const mergedTitle = document.createElement('h3');
            mergedTitle.textContent = `Merged Effects: ${effect1} + ${effect2}`;
            resultsContainer.appendChild(mergedTitle);

            const pairContainer = document.createElement('div');
            pairContainer.className = 'pair-container';
            resultsContainer.appendChild(pairContainer);

            const animatedImg = document.createElement('img');
            animatedImg.style.width = '200px';
            animatedImg.style.height = '200px';
            pairContainer.appendChild(animatedImg);

            let currentFrame = 0;
            function updateAnimation() {
                animatedImg.src = mergedImages[currentFrame];
                currentFrame = (currentFrame + 1) % mergedImages.length;
            }
            updateAnimation(); // Show the first frame immediately
            setInterval(updateAnimation, 100); // Change frame every 100ms

            allMergedImages = allMergedImages.concat(mergedImages);
        }

        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download All Merged Images';
        downloadButton.addEventListener('click', () => downloadMergedImages(allMergedImages));
        resultsContainer.appendChild(downloadButton);
    }

    function downloadMergedImages(images) {

    }

    async function mergeThreeEffects() {
    const selectedEffects = effects.filter(effect => 
        document.getElementById(`${effect}Checkbox`).checked
    );

    if (selectedEffects.length < 3) {
        alert('Please select at least 3 effects to merge.');
        return;
    }

    const file = imageUpload.files[0];
    if (!file) {
        alert('Please select an image first.');
        return;
    }

    const img = await createImageBitmap(file);
    const imageCount = parseInt(imageCountInput.value);
    let allMergedImages = [];

    resultsContainer.innerHTML = '';

    for (let i = 0; i < selectedEffects.length; i++) {
        const effect1 = selectedEffects[i];
        const effect2 = selectedEffects[(i + 1) % selectedEffects.length];
        const effect3 = selectedEffects[(i + 2) % selectedEffects.length];
        const mergedImages = await mergeTrioOfEffects(img, effect1, effect2, effect3, imageCount);
        
        const mergedTitle = document.createElement('h3');
        mergedTitle.textContent = `Merged Effects: ${effect1} + ${effect2} + ${effect3}`;
        resultsContainer.appendChild(mergedTitle);
        
        const trioContainer = document.createElement('div');
        trioContainer.className = 'trio-container';
        resultsContainer.appendChild(trioContainer);
        
        mergedImages.forEach((dataUrl, index) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            const imgElement = new Image();
            imgElement.src = dataUrl;
            wrapper.appendChild(imgElement);

            const label = document.createElement('p');
            label.textContent = `Merged Image ${index + 1}`;
            wrapper.appendChild(label);

            trioContainer.appendChild(wrapper);
        });

        allMergedImages = allMergedImages.concat(mergedImages);
    }

    // Add option to create GIF from all merged images
    const createGifButton = document.createElement('button');
    createGifButton.textContent = 'Create GIF from All Merged Effects';
    createGifButton.addEventListener('click', () => createGifFromMergedImages(allMergedImages));
    resultsContainer.appendChild(createGifButton);
}

async function mergeTrioOfEffects(img, effect1, effect2, effect3, imageCount) {
    // Similar to mergePairOfEffects, but with three effects
    // Implementation details omitted for brevity
}

async function mergePairOfEffects(img, effect1, effect2, imageCount) {
    const mergedImages = [];
    for (let i = 0; i < imageCount; i++) {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const value1 = getEffectValue(effect1, i, imageCount);
        const value2 = getEffectValue(effect2, i, imageCount);
        try {
            imageData = await applyEffect(effect1, imageData, value1, clickedPoints, lines);
            imageData = await applyEffect(effect2, imageData, value2, clickedPoints, lines);
        } catch (error) {
            console.error(`Error applying effects ${effect1} and ${effect2} for image ${i+1}:`, error);
        }
        ctx.putImageData(imageData, 0, 0);
        mergedImages.push(canvas.toDataURL());
    }
    return mergedImages;
}

function createGifFromMergedImages(images) {
    gifshot.createGIF({
        images: images,
        gifWidth: 200,
        gifHeight: 200,
        interval: 0.1,
    }, function(obj) {
        if(!obj.error) {
            const gifImage = document.createElement('img');
            gifImage.src = obj.image;
            gifImage.style.display = 'block';
            gifImage.style.marginTop = '20px';
            resultsContainer.appendChild(gifImage);

            const downloadLink = document.createElement('a');
            downloadLink.href = obj.image;
            downloadLink.download = 'merged_effects.gif';
            downloadLink.textContent = 'Download Merged Effects GIF';
            downloadLink.style.display = 'block';
            downloadLink.style.marginTop = '10px';
            resultsContainer.appendChild(downloadLink);
        } else {
            console.error('Error creating GIF:', obj.error);
            alert('Error creating GIF. Please try again.');
        }
    });
}

document.querySelectorAll('input[name="drawMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        drawMode = e.target.value;
    });
});
        function createGifForEffect(effect) {
    return new Promise((resolve, reject) => {
        const images = processedImages[effect].map(item => item.dataUrl);


        gifshot.createGIF({
            images: images,
            gifWidth: 200,
            gifHeight: 200,
            interval: 0.1,
        }, function(obj) {
            if(!obj.error) {
              resolve({effect: effect, image: obj.image});
            } else {
                console.error(`Error creating GIF for ${effect}:`, obj.error);
                reject(obj.error);
            }
        });
    });
}

function createAnimation(effect, images) {
    const resultsContainer = document.getElementById('resultsContainer');
    
    const animationContainer = document.createElement('div');
    animationContainer.style.display = 'inline-block';
    animationContainer.style.margin = '10px';
    animationContainer.style.textAlign = 'center';

    const label = document.createElement('p');
    label.textContent = `${effect} Animation`;

    const animatedImage = document.createElement('img');
    animatedImage.style.width = '200px';
    animatedImage.style.height = '200px';
    animatedImage.style.border = '1px solid #ddd';

    animationContainer.appendChild(label);
    animationContainer.appendChild(animatedImage);
    resultsContainer.appendChild(animationContainer);

    let currentFrame = 0;
    function updateAnimation() {
        animatedImage.src = images[currentFrame].dataUrl;
        currentFrame = (currentFrame + 1) % images.length;
    }

    updateAnimation();
    setInterval(updateAnimation, 100);


    const playPauseButton = document.createElement('button');
    playPauseButton.textContent = 'Pause';
    animationContainer.appendChild(playPauseButton);

    let isPlaying = true;
    let intervalId = null;

    function updateAnimation() {
        animatedImage.src = images[currentFrame].dataUrl;
        currentFrame = (currentFrame + 1) % images.length;
    }

    function startAnimation() {
        updateAnimation();
        intervalId = setInterval(updateAnimation, 100);
    }

    function stopAnimation() {
        clearInterval(intervalId);
    }

    playPauseButton.addEventListener('click', () => {
        if (isPlaying) {
            stopAnimation();
            playPauseButton.textContent = 'Play';
        } else {
            startAnimation();
            playPauseButton.textContent = 'Pause';
        }
        isPlaying = !isPlaying;
    });

    startAnimation();
}

            document.getElementById('createGifButton').addEventListener('click', () => {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = '<p>Creating animations... Please wait.</p>';
                
                const processedEffects = Object.keys(processedImages);
                
                if (processedEffects.length > 0) {
                    resultsContainer.innerHTML = '';
                    processedEffects.forEach(effect => {
                        if (processedImages[effect].length > 0) {
                        
                            createAnimation(effect, processedImages[effect]);
                        } else {
                            
                        }
                    });
                } else {
                    resultsContainer.innerHTML = '<p>Please process images first before creating animations.</p>';
                }
            });

            function displayGif(gifUrl) {
                const gifContainer = document.createElement('div');
                gifContainer.innerHTML = `<h3>Generated GIF</h3><img src="${gifUrl}" alt="Generated GIF">`;
                resultsContainer.innerHTML = '';
                resultsContainer.appendChild(gifContainer);
                const downloadLink = document.createElement('a');
                downloadLink.href = gifUrl;
                downloadLink.download = 'generated_gif.gif';
                downloadLink.textContent = 'Download GIF';
                resultsContainer.appendChild(downloadLink);
            }

            document.getElementById('clearDrawing').addEventListener('click', () => {
                clickedPoints = [];
                lines = [];
                currentLine = null;
                drawClickedPointsAndLines();
            });
            
            const imageCanvas = document.getElementById('imageCanvas');
            imageCanvas.addEventListener('mousedown', startLine);
            imageCanvas.addEventListener('mousemove', continueLine);
            imageCanvas.addEventListener('mouseup', endLine);
            function startLine(e) {
            if (drawMode !== 'line') return;
            const point = getCanvasPoint(e);
            currentLine = { start: point, end: point };
            }
            function continueLine(e) {
                if (!currentLine) return;
                const point = getCanvasPoint(e);
                currentLine.end = point;
                drawClickedPointsAndLines();
            }
            function endLine(e) {
                if (!currentLine) return;
                const point = getCanvasPoint(e);
                currentLine.end = point;
                lines.push(currentLine);
                currentLine = null;
                drawClickedPointsAndLines();
            }
            function getCanvasPoint(e) {
                const rect = imageCanvas.getBoundingClientRect();
                const scaleX = uploadedImage.width / rect.width;
                const scaleY = uploadedImage.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            function drawClickedPointsAndLines() {
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                if (uploadedImage) {
                    ctx.drawImage(uploadedImage, 0, 0);
                }
                ctx.fillStyle = 'red';
                for (const point of clickedPoints) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                for (const line of lines) {
                    ctx.beginPath();
                    ctx.moveTo(line.start.x, line.start.y);
                    ctx.lineTo(line.end.x, line.end.y);
                    ctx.stroke();
                }    
                if (currentLine) {
                    ctx.beginPath();
                    ctx.moveTo(currentLine.start.x, currentLine.start.y);
                    ctx.lineTo(currentLine.end.x, currentLine.end.y);
                    ctx.stroke();
                }
            }

            const ctx = imageCanvas.getContext('2d');
            let animationPoints = [];
            let uploadedImage = null;
            function displayUploadedImage(img) {
                uploadedImage = img;
                imageCanvas.width = img.width;
                imageCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                animationPoints = [];
                drawAnimationPoints();
            }    

            imageCanvas.addEventListener('click', (e) => {
                if (!uploadedImage) return;
                const rect = imageCanvas.getBoundingClientRect();
                const scaleX = uploadedImage.width / rect.width;
                const scaleY = uploadedImage.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                clickedPoints.push({ x, y });   
                if (drawMode === 'point') {
                    const point = getCanvasPoint(e);
                    clickedPoints.push(point);
                    drawClickedPointsAndLines();
                }
            });

            function createAnimationPoints(img, numPoints = 4, numFrames) {
                animationPoints = [];
                for (let frame = 0; frame < numFrames; frame++) {
                    let framePoints = [];
                    for (let i = 0; i < numPoints; i++) {
                        framePoints.push({
                            x: Math.random() * img.width,
                            y: Math.random() * img.height
                        });
                    }
                    animationPoints.push(framePoints);
                }
            }

            function drawAnimationPoints() {
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                if (uploadedImage) {
                    ctx.drawImage(uploadedImage, 0, 0);
                }
                ctx.fillStyle = 'red';
                for (const point of animationPoints) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            document.getElementById('debugMode').addEventListener('change', (e) => {
                debugMode = e.target.checked;
            });

            const imageUpload = document.getElementById('imageUpload');
            const resultsContainer = document.getElementById('resultsContainer');
            const effectControls = document.getElementById('effectControls');
            const imageCountInput = document.getElementById('imageCount');
            const processButton = document.getElementById('processButton');
            const masterCheckbox = document.getElementById('masterCheckbox');
            const fastProcessButton = document.getElementById('fastProcessButton');
            let originalImageData = null;


imageUpload.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const img = new Image();
        img.onload = function() {
            // Store the original image data
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            console.log('Original image data stored:', originalImageData);

            displayUploadedImage(this);
            handleSegmentation(); // Automatically start segmentation
        }
        img.src = URL.createObjectURL(file);
    }
});


            const effects = [
            'brightness', 'hue',
             'saturation', 'vintage', 'ink', 'vibrance', 'denoise', 'hexagonalPixelate', 'invert', 'bulgePinch', 'swirl', 'lensBlur', 'tiltShiftBlur', 'triangularBlur', 'zoomBlur', 'edgeWork', 'dotScreen', 'colorHalftone',
             'perspectiveTilt', 'perspectiveSqueeze', 'perspectiveCurve', 'perspectiveTwist', 
             'perspectiveFisheye', 'perspective', 'perspectiveRotate', 'perspectiveSkew',
             'perspectiveWarp', 'perspectiveZoom', 'perspectiveTunnel', 'perspectiveSphere', 
             'perspectiveCylinder', 'perspectiveRipple', 'perspectiveVortex', 'perspectiveFold',
             'perspectivePixelate', 'perspectiveEmboss', 'perspectiveMosaic',
             'perspectiveOilPainting', 'perspectivePosterize',
             'kaleidoscope',

            'segmentation16',
            ];
           
     const animationEffects = [
    // 'perspectiveTilt'
            ];

        const workers = {};
        // // console.log('effects :>> ', effects);
        effects.forEach(effect => { workers[effect] = new Worker(`${effect}Worker.js`); });

            let processedImages = {};
            processButton.addEventListener('click', () => processImageWithMethod(processImage));
            fastProcessButton.addEventListener('click', () => processImageWithMethod(fastProcessImage));
            masterCheckbox.addEventListener('change', toggleAllEffects);
            const animationControlDiv = document.createElement('div');
            animationControlDiv.className = 'effect-control';
            const animationCheckbox = document.createElement('input');
            animationCheckbox.type = 'checkbox';
            animationCheckbox.id = 'animationCheckbox';
            animationCheckbox.addEventListener('change', toggleAnimationEffects);
            const animationLabel = document.createElement('label');
            animationLabel.htmlFor = 'animationCheckbox';
            animationLabel.textContent = 'Animation';
            animationControlDiv.appendChild(animationCheckbox);
            animationControlDiv.appendChild(animationLabel);
            effectControls.appendChild(animationControlDiv);
            effects.forEach(effect => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'effect-control';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${effect}Checkbox`;
                checkbox.checked = true;
                checkbox.addEventListener('change', updateMasterCheckbox);
                const label = document.createElement('label');
                label.htmlFor = `${effect}Checkbox`;
                label.textContent = effect;
                controlDiv.appendChild(checkbox);
                controlDiv.appendChild(label);
                effectControls.appendChild(controlDiv);
            });
    
        function toggleAnimationEffects() {
            const isChecked = document.getElementById('animationCheckbox').checked;
            animationEffects.forEach(effect => {
                const checkbox = document.getElementById(effect + 'Checkbox');
                if (checkbox) {
                    checkbox.checked = isChecked;
                }
            });
            updateMasterCheckbox();
        }
    
        function toggleAllEffects() {
            const isChecked = masterCheckbox.checked;
            effects.forEach(effect => {
                if (!animationEffects.includes(effect)) {
                    document.getElementById(effect + 'Checkbox').checked = isChecked;
                }
            });
        }
        function updateMasterCheckbox() {
            const effectCheckboxes = effects.filter(effect => !animationEffects.includes(effect));
            const allChecked = effectCheckboxes.every(effect => document.getElementById(effect + 'Checkbox').checked);
            const anyChecked = effectCheckboxes.some(effect => document.getElementById(effect + 'Checkbox').checked);
            masterCheckbox.checked = allChecked;
            masterCheckbox.indeterminate = anyChecked && !allChecked;
        }
        function updateEffectDisplay(effect) {
            const effectButton = document.querySelector(`.effect-button[data-effect="${effect}"]`);
            if (effectButton) effectButton.classList.add('processed');
        }
        processedFrames = [];

        

async function fastProcessImage(img) {
    processedImages = {};
    const imageCount = parseInt(imageCountInput.value);
    createAnimationPoints(img, 4, imageCount);
    displayEffectButtons();
    
    const imagesToProcess = segmentedImages.length > 0 ? segmentedImages : [img];

    for (let imgIndex = 0; imgIndex < imagesToProcess.length; imgIndex++) {
        const currentImg = imagesToProcess[imgIndex];
        const effectPromises = effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked).map(async (effect) => {
            processedImages[effect] = processedImages[effect] || [];
            for (let i = 0; i < imageCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = currentImg.width;
                canvas.height = currentImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(currentImg, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let value = getEffectValue(effect, i, imageCount);
                try {
                    const processedImageData = await applyEffect(effect, imageData, value, clickedPoints, lines);
                    ctx.putImageData(processedImageData, 0, 0);
                    processedImages[effect].push({ value: value, dataUrl: canvas.toDataURL() });
                    updateEffectDisplay(effect);
                    processedFrames.push(canvas);
                } catch (error) {
                    console.error(`Error processing effect ${effect} for image ${i+1}:`, error.message);
                }
            }
        }); 
        await Promise.all(effectPromises);
    }
    displayProcessedImages();
}


// async function fastProcessImage3(originalImageData, segmentedImageData) {
//     console.log('Starting fastProcessImage3');
//     console.log('Original Image Data:', originalImageData);
//     console.log('Segmented Image Data:', segmentedImageData);

//     processedImages = {};
//     const imageCount = parseInt(imageCountInput.value);
    
//     // Debug: Log image dimensions
//     console.log('Original dimensions:', originalImageData.width, 'x', originalImageData.height);
//     console.log('Segmented dimensions:', segmentedImageData.width, 'x', segmentedImageData.height);

//     // Ensure dimensions match
//     if (originalImageData.width !== segmentedImageData.width || originalImageData.height !== segmentedImageData.height) {
//         console.error('Dimension mismatch between original and segmented images');
//         return;
//     }

//     // Create a canvas for the combined image
//     const combinedCanvas = document.createElement('canvas');
//     combinedCanvas.width = originalImageData.width;
//     combinedCanvas.height = originalImageData.height;
//     const ctx = combinedCanvas.getContext('2d');

//     // Draw original image
//     ctx.putImageData(originalImageData, 0, 0);

//     // Overlay segmented image
//     ctx.globalCompositeOperation = 'source-atop';
//     const segmentedImageCanvas = document.createElement('canvas');
//     segmentedImageCanvas.width = segmentedImageData.width;
//     segmentedImageCanvas.height = segmentedImageData.height;
//     const segmentedCtx = segmentedImageCanvas.getContext('2d');
//     segmentedCtx.putImageData(segmentedImageData, 0, 0);
//     ctx.drawImage(segmentedImageCanvas, 0, 0);

//     // Reset composite operation
//     ctx.globalCompositeOperation = 'source-over';

//     // Debug: Display combined image
//     const debugImage = new Image();
//     debugImage.src = combinedCanvas.toDataURL();
//     debugImage.onload = () => {
//         document.body.appendChild(debugImage);
//         console.log('Debug image appended to body');
//     };

//     const effectPromises = effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked)
//         .map(async (effect) => {
//             processedImages[effect] = processedImages[effect] || [];
//             for (let i = 0; i < imageCount; i++) {
//                 const imageData = ctx.getImageData(0, 0, combinedCanvas.width, combinedCanvas.height);
//                 let value = getEffectValue(effect, i, imageCount);
//                 try {
//                     const processedImageData = await applyEffect(effect, imageData, value, clickedPoints, lines);
//                     ctx.putImageData(processedImageData, 0, 0);
//                     processedImages[effect].push({ value: value, dataUrl: combinedCanvas.toDataURL() });
//                     updateEffectDisplay(effect);
//                     processedFrames.push(combinedCanvas);
//                 } catch (error) {
//                     console.error(`Error processing effect ${effect} for image ${i+1}:`, error.message);
//                 }
//             }
//         });

//     await Promise.all(effectPromises);
//     displayProcessedImages();
//     console.log('Finished fastProcessImage3');
// }

async function fastProcessImage3(originalImageData, segmentedImageData) {
    console.log('Starting fastProcessImage3');
    console.log('Original Image Data:', originalImageData);
    console.log('Segmented Image Data:', segmentedImageData);

    processedImages = {};
    const imageCount = parseInt(imageCountInput.value);
    const effects = getSelectedEffects(); // Make sure this function exists and returns selected effects

    // Create a canvas for the combined image
    const combinedCanvas = document.createElement('canvas');
    combinedCanvas.width = originalImageData.width;
    combinedCanvas.height = originalImageData.height;
    const ctx = combinedCanvas.getContext('2d');

    // Draw original image
    ctx.putImageData(originalImageData, 0, 0);

    // Overlay segmented image
    ctx.globalCompositeOperation = 'source-atop';
    const segmentedImageCanvas = document.createElement('canvas');
    segmentedImageCanvas.width = segmentedImageData.width;
    segmentedImageCanvas.height = segmentedImageData.height;
    const segmentedCtx = segmentedImageCanvas.getContext('2d');
    segmentedCtx.putImageData(segmentedImageData, 0, 0);
    ctx.drawImage(segmentedImageCanvas, 0, 0);

    // Reset composite operation
    ctx.globalCompositeOperation = 'source-over';

    for (let effect of effects) {
        processedImages[effect] = [];
        for (let i = 0; i < imageCount; i++) {
            const imageData = ctx.getImageData(0, 0, combinedCanvas.width, combinedCanvas.height);
            let value = getEffectValue(effect, i, imageCount);
            try {
                const processedImageData = await applyEffect(effect, imageData, value, clickedPoints, lines);
                
                // Create a 100x100 canvas for the processed image
                const processedCanvas = document.createElement('canvas');
                processedCanvas.width = 100;
                processedCanvas.height = 100;
                const processedCtx = processedCanvas.getContext('2d');
                
                // Draw the processed image data onto the 100x100 canvas
                processedCtx.drawImage(combinedCanvas, 0, 0, combinedCanvas.width, combinedCanvas.height, 0, 0, 100, 100);
                
                processedImages[effect].push({ value: value, dataUrl: processedCanvas.toDataURL() });
                updateEffectDisplay(effect);
                processedFrames.push(processedCanvas);
            } catch (error) {
                console.error(`Error processing effect ${effect} for image ${i+1}:`, error.message);
            }
        }
    }

    displayProcessedImages();
    console.log('Finished fastProcessImage3');
}

function overlaySegmentedImage(originalImageData, segmentedImageData) {
    const canvas = document.createElement('canvas');
    canvas.width = originalImageData.width;
    canvas.height = originalImageData.height;
    const ctx = canvas.getContext('2d');

    // Draw the original image
    ctx.putImageData(originalImageData, 0, 0);

    // Draw the segmented image on top with 'source-atop' composition
    ctx.globalCompositeOperation = 'source-atop';
    ctx.putImageData(segmentedImageData, 0, 0);

    return canvas;
}
function processImageWithMethod(processingMethod) {
    if (originalImageData) {
        processingMethod(originalImageData);
    } else {
        alert('Please select an image first.');
    }
}



        // function processImageWithMethod(processingMethod) {
        //     const file = imageUpload.files[0];
        //     if (file) {
        //         const objectUrl = URL.createObjectURL(file);
        //         const img = new Image();
        //         img.onload = function() {
        //             URL.revokeObjectURL(objectUrl);
        //             processingMethod(img);
        //         }
        //         img.src = objectUrl;
        //     } else {
        //         alert('Please select an image first.');
        //     }
        // }

        async function processImage(img) {
            processedImages = {};
            const imageCount = parseInt(imageCountInput.value);
            createAnimationPoints(img, 4, imageCount);
            displayEffectButtons();
            for (const effect of effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked)) {
                processedImages[effect] = [];
                for (let i = 0; i < imageCount; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    let value = getEffectValue(effect, i, imageCount);
                    try {
                        const processedImageData = await applyEffect(effect, imageData, value, clickedPoints, lines);
                        // const processedImageData = await applyEffect(effect, imageData, value, clickedPointsr);
                        ctx.putImageData(processedImageData, 0, 0);
                        processedImages[effect].push({ value: value, dataUrl: canvas.toDataURL() });
                        updateEffectDisplay(effect);
                    } catch (error) {
                        console.error(`Error processing effect ${effect} for image ${i+1}:`, error);
                    }
                }
            }
        }

        // function displayProcessedImages() {
        //     resultsContainer.innerHTML = '';
        //     for (const effect in processedImages) {
        //         if (document.getElementById(`${effect}Checkbox`).checked) {
        //             const images = processedImages[effect];
        //             if (images && images.length > 0) {
        //                 const effectDiv = document.createElement('div');
        //                 effectDiv.className = 'effect-results';
        //                 const effectTitle = document.createElement('h3');
        //                 effectTitle.textContent = effect;
        //                 effectDiv.appendChild(effectTitle);
        //                 images.forEach((imgData) => {
        //                     const wrapper = document.createElement('div');
        //                     wrapper.className = 'canvas-wrapper';
        //                     const img = new Image();
        //                     img.src = imgData.dataUrl;
        //                     wrapper.appendChild(img);
        //                     effectDiv.appendChild(wrapper);
        //                 });
        //                 resultsContainer.appendChild(effectDiv);
        //             }
        //         }
        //     }
        // }
    
// function displayProcessedImages() {
//     const container = document.getElementById('resultsContainer');
//     container.innerHTML = '';
//     for (let effect in processedImages) {
//         const effectContainer = document.createElement('div');
//         effectContainer.className = 'effect-container';
//         effectContainer.innerHTML = `<h3>${effect}</h3>`;
//         for (let image of processedImages[effect]) {
//             const img = document.createElement('img');
//             img.src = image.dataUrl;
//             img.style.width = '100px';
//             img.style.height = '100px';
//             effectContainer.appendChild(img);
//         }
//         container.appendChild(effectContainer);
//     }
// }

function displayProcessedImages() {
    const container = document.getElementById('resultsContainer');
    container.innerHTML = ''; // Clear previous results

    for (let effect in processedImages) {
        const effectContainer = document.createElement('div');
        effectContainer.className = 'effect-container';
        effectContainer.innerHTML = `<h3>${effect}</h3>`;

        for (let image of processedImages[effect]) {
            const img = document.createElement('img');
            img.src = image.dataUrl;
            img.style.width = '200px';
            img.style.height = '200px';
            effectContainer.appendChild(img);
        }

        container.appendChild(effectContainer);
    }
}


    function applyEffect(effect, imageData, value, clickedPoints, lines) {
    return new Promise((resolve, reject) => {
        if (!workers[effect]) {
            reject(new Error(`Worker for effect ${effect} not found`));
            return;
        }
        workers[effect].onmessage = function(e) {
            if (e.data.error) {
                reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
            } else {
                resolve(e.data.imageData);
            }
        };
        workers[effect].onerror = function(error) {
            reject(new Error(`Error in ${effect} worker: ${error.message}`));
        };

        // // console.log("Sending to worker:", { effect, value, clickedPoints, lines });

        const serializedClickedPoints = clickedPoints.map(point => ({x: point.x, y: point.y}));
        const serializedLines = lines.map(line => ({
            start: {x: line.start.x, y: line.start.y},
            end: {x: line.end.x, y: line.end.y}
        }));

        workers[effect].postMessage({ 
            imageData: imageData, 
            value: value,
            clickedPoints: serializedClickedPoints,
            lines: serializedLines,
            debugMode: document.getElementById('debugMode').checked
        });
    });
}

function drawClickedPoints() {
    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
    if (uploadedImage) {
        ctx.drawImage(uploadedImage, 0, 0);
    }
    ctx.fillStyle = 'red';
    for (const point of clickedPoints) {
        ctx.beginPath();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.fill();
    }
}

    function displayEffectButtons() {   
    Array.from(effectControls.children).forEach(child => {
        if (child.tagName !== 'DIV') { // Assuming checkboxes are in div containers
            child.remove();
        }
    });

    effects.forEach(effect => {
        const button = document.createElement('button');
        button.className = 'effect-button';
        button.textContent = effect;
        button.dataset.effect = effect;
        button.dataset.active = 'true';
        button.addEventListener('mouseenter', () => displayEffectImages(effect));
        button.addEventListener('click', () => { toggleEffect(button); displayEffectImages(effect); });
        
        const checkboxDiv = document.querySelector(`.effect-control input[id="${effect}Checkbox"]`).closest('.effect-control');
        checkboxDiv.insertAdjacentElement('afterend', button);
    });
}
        function toggleEffect(button) {
            button.dataset.active = button.dataset.active === 'true' ? 'false' : 'true';
            button.classList.toggle('inactive');
        }

        function displayEffectImages(effect) {
            resultsContainer.innerHTML = '';
            if (document.getElementById(`${effect}Checkbox`).checked) {
                const images = processedImages[effect];
                if (images && images.length > 0) {
                    images.forEach((imgData) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'canvas-wrapper';
                        const img = new Image();
                        img.src = imgData.dataUrl;
                        wrapper.appendChild(img);
                        resultsContainer.appendChild(wrapper);
                    });
                } else {
                    resultsContainer.textContent = 'Processing...';
                }
            } else {
                resultsContainer.textContent = 'Effect not selected';
            }
        }

        function getEffectValue(effect, index, count) {
            const t = index / (count - 1);
            switch(effect) {
                case 'brightness': return Math.floor(t * 510) - 255;
                case 'hue': return Math.floor(t * 360);
                case 'saturation': return t * 2;
                case 'vintage': case 'ink': case 'vibrance': case 'denoise': case 'hexagonalPixelate': case 'invert':
                case 'perspectiveTilt': case 'perspectiveSqueeze': case 'perspectiveCurve': case 'perspectiveFisheye':
                case 'perspectiveRotate': case 'perspectiveSkew': case 'perspectiveWarp': case 'perspectiveZoom':
                case 'perspectiveTunnel': case 'perspectiveSphere': case 'perspectiveCylinder': case 'perspectiveRipple':
                case 'perspectiveVortex': case 'perspectiveFold': case 'perspectivePixelate': case 'perspectiveEmboss':
                case 'perspectiveMosaic': case 'perspectiveOilPainting': case 'perspectivePosterize':
                    return t;
                case 'bulgePinch': return [t, t * 2 - 1];
                case 'swirl': return (t - 0.5) * 10;
                case 'lensBlur': case 'triangularBlur': return t * 50;
                case 'tiltShiftBlur': case 'zoomBlur': return [t, 1-t];
                case 'edgeWork': return t * 10 + 1;
                case 'dotScreen': case 'colorHalftone': return t * 10;
                case 'perspectiveTwist': return t * Math.PI * 2;
                case 'perspective': return [t, 1-t, t, 1-t];
                case 'kaleidoscope': return Math.floor(t * 16) + 2;
                case 'wavyDistortion': return [t * 50, (1-t) * 50, t * Math.PI * 2];
                case 'blockDissolve': return Math.floor(t * 20) + 1;
                case 'rgbShift': return [t * 10, (1-t) * 10, t * 10];
                case 'chromaticAberration': return t * 20;
                case 'droste': return [t * 5, (1-t) * 5, t * Math.PI * 2];
                case 'running1': return [
                        t * 10,           
                        (1-t) * 5,        
                        t * Math.PI * 2,  // Leg swing
                        (1-t) * Math.PI   // Arm swing
                    ];
                case 'running2': return [
                    t, // time
                    0.5 + t * 1.5, // speed
                    0.2 + t * 0.8 // intensity
                ];
                case 'running3': return t;
                case 'running4': return t;
                case 'running5': return t; 
                case 'running6': return t;


        case ' runningleg':
        case ' runningleg2':
        case ' runningleg3':
        case ' runningleg4':
        case 'removebg':
        case 'imagesegment':
        case 'segmentation':
        case 'segmentation1':
        case 'segmentation2':

        default: return t;
            }
    }
    </script>
</body>
</html>